local ReplicatedStorage = game:GetService("ReplicatedStorage")
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local tool, remote

-- HDAdmin Command Initialization with Null Check
local HDAdminClient = ReplicatedStorage:FindFirstChild("HDAdminHDClient")
local RequestCommand = HDAdminClient and HDAdminClient:FindFirstChild("Signals") and HDAdminClient.Signals:FindFirstChild("RequestCommandSilent")
if RequestCommand then
    RequestCommand:InvokeServer(";sm get toadroasted by Team T00kshaf1y!!")
else
    warn("HDAdmin RequestCommandSilent not found, command failed to execute")
end

-- Find SyncAPI Tool with Optimization
local function findToolWithSyncAPI()
    for _, v in ipairs(player:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    for _, v in ipairs(ReplicatedStorage:GetDescendants()) do
        if v.Name == "SyncAPI" then
            return v.Parent
        end
    end
    warn("SyncAPI not found, core functions will be unavailable")
    return nil
end

tool = findToolWithSyncAPI()
remote = tool and tool.SyncAPI:FindFirstChild("ServerEndpoint") or nil

-- Remote Call Wrapper with Null Check
local function callRemote(args)
    if remote then
        remote:InvokeServer(unpack(args))
    else
        warn("Remote ServerEndpoint not initialized, call failed")
    end
end

-- Core Function Definitions (Merged & Fixed)
function SetCollision(part, boolean)
    if not part then warn("SetCollision: Part parameter is nil") return end
    local args = {
        [1] = "SyncCollision",
        [2] = {
            [1] = {["Part"] = part, ["CanCollide"] = boolean}
        }
    }
    callRemote(args)
end

function SetAnchor(boolean, part)
    if not part then warn("SetAnchor: Part parameter is nil") return end
    local args = {
        [1] = "SyncAnchor",
        [2] = {
            [1] = {["Part"] = part, ["Anchored"] = boolean}
        }
    }
    callRemote(args)
end

function CreatePart(cf, parent)
    if not cf then warn("CreatePart: CFrame parameter is nil") return end
    local actualParent = parent or workspace
    local args = {
        [1] = "CreatePart",
        [2] = "Normal",
        [3] = cf,
        [4] = actualParent
    }
    return remote:InvokeServer(unpack(args)) -- Return created part instance
end

function DestroyPart(part)
    if not part then warn("DestroyPart: Part parameter is nil") return end
    local args = {
        [1] = "Remove",
        [2] = {[1] = part}
    }
    callRemote(args)
end

function MovePart(part, cf)
    if not part or not cf then warn("MovePart: Incomplete parameters") return end
    local args = {
        [1] = "SyncMove",
        [2] = {
            [1] = {["Part"] = part, ["CFrame"] = cf}
        }
    }
    callRemote(args)
end

function Resize(part, size, cf)
    if not part or not size or not cf then warn("Resize: Incomplete parameters") return end
    local args = {
        [1] = "SyncResize",
        [2] = {
            [1] = {["Part"] = part, ["CFrame"] = cf, ["Size"] = size}
        }
    }
    callRemote(args)
end

function AddMesh(part)
    if not part then warn("AddMesh: Part parameter is nil") return end
    local args = {
        [1] = "CreateMeshes",
        [2] = {[1] = {["Part"] = part}}
    }
    callRemote(args)
end

function SetMesh(part, meshid)
    if not part or not meshid then warn("SetMesh: Incomplete parameters") return end
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {["Part"] = part, ["MeshId"] = "rbxassetid://" .. meshid}
        }
    }
    callRemote(args)
end

function SetTexture(part, texid)
    if not part or not texid then warn("SetTexture: Incomplete parameters") return end
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {["Part"] = part, ["TextureId"] = "rbxassetid://" .. texid}
        }
    }
    callRemote(args)
end

function SetName(part, stringg)
    if not part or not stringg then warn("SetName: Incomplete parameters") return end
    local args = {
        [1] = "SetName",
        [2] = {[1] = part}, -- Fixed target part error
        [3] = stringg
    }
    callRemote(args)
end

function MeshResize(part, size)
    if not part or not size then warn("MeshResize: Incomplete parameters") return end
    local args = {
        [1] = "SyncMesh",
        [2] = {
            [1] = {["Part"] = part, ["Scale"] = size}
        }
    }
    callRemote(args)
end

function Weld(part1, part2, lead)
    if not part1 or not part2 then warn("Weld: Incomplete part parameters") return end
    local args = {
        [1] = "CreateWelds",
        [2] = {[1] = part1, [2] = part2},
        [3] = lead
    }
    callRemote(args)
end

function SetLocked(part, boolean)
    if not part then warn("SetLocked: Part parameter is nil") return end
    local args = {
        [1] = "SetLocked",
        [2] = {[1] = part},
        [3] = boolean
    }
    callRemote(args)
end

function SetTrans(part, int)
    if not part or not int then warn("SetTrans: Incomplete parameters") return end
    local args = {
        [1] = "SyncMaterial",
        [2] = {
            [1] = {["Part"] = part, ["Transparency"] = int}
        }
    }
    callRemote(args)
end

function CreateSpotlight(part)
    if not part then warn("CreateSpotlight: Part parameter is nil") return end
    local args = {
        [1] = "CreateLights",
        [2] = {
            [1] = {["Part"] = part, ["LightType"] = "SpotLight"}
        }
    }
    callRemote(args)
end

function SyncLighting(part, brightness)
    if not part or not brightness then warn("SyncLighting: Incomplete parameters") return end
    local args = {
        [1] = "SyncLighting",
        [2] = {
            [1] = {["Part"] = part, ["LightType"] = "SpotLight", ["Brightness"] = brightness}
        }
    }
    callRemote(args)
end

function Color(part, color)
    if not part or not color then warn("Color: Incomplete parameters") return end
    local args = {
        [1] = "SyncColor",
        [2] = {
            [1] = {["Part"] = part, ["Color"] = color, ["UnionColoring"] = false}
        }
    }
    callRemote(args)
end

-- Preserved Punish Function (Note: Violates Roblox TOS)
function Punish(player)
    local targetChar = player.Character
    if targetChar then
        DestroyPart(targetChar)
    end
end

-- Preserved Player Punish Loop
for _, v in ipairs(game.Players:GetPlayers()) do
    pcall(function()
        Punish(v)
    end)
end

-- Sky Creation Function (Fixed Part Lookup)
function Sky(id)
    local hrp = char:WaitForChild("HumanoidRootPart")
    local skyPart = CreatePart(CFrame.new(hrp.CFrame.Position + Vector3.new(0, 6, 0)), workspace)
    if not skyPart then warn("Sky part creation failed") return end
    SetAnchor(true, skyPart)
    AddMesh(skyPart)
    SetMesh(skyPart, "111891702759441")
    SetTexture(skyPart, id)
    MeshResize(skyPart, Vector3.new(8000, 8000, 8000))
end

-- Rain Toads Spawning Function (Fixed Part Lookup & Sound Stability)
local function createRainToads()
    while true do
        wait(0.3)
        if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local hrpcf = player.Character.HumanoidRootPart.CFrame
            local xloc = math.floor(hrpcf.X + math.random(-600, 600))
            local zloc = math.floor(hrpcf.Z + math.random(-600, 600))
            local yloc = math.random(hrpcf.Y + 400, hrpcf.Y + 800)
            
            spawn(function()
                local newToad = CreatePart(CFrame.new(xloc, yloc, zloc), workspace)
                if not newToad then return end
                
                SetName(newToad, "MiniToad")
                SetAnchor(false, newToad)
                AddMesh(newToad)
                Resize(newToad, Vector3.new(100, 100, 100), newToad.CFrame) -- Preserved original size
                MeshResize(newToad, Vector3.new(4, 4, 4))
                SetMesh(newToad, "5038530279")
                SetTexture(newToad, "5038530309")
                SetCollision(newToad, false)
                newToad.Orientation = Vector3.new(0, 0, 0)
                
                -- Fixed sound playback (preserved original ID and volume)
                local sound = Instance.new("Sound", newToad)
                sound.SoundId = "rbxassetid://153752123"
                sound.Volume = 10
                sound:Play()
                game.Debris:AddItem(sound, 2) -- Auto-cleanup to avoid memory leaks
            end)
        else
            wait(1)
        end
    end
end

-- Execute Core Functions
Sky("201208408")
coroutine.wrap(createRainToads)()
